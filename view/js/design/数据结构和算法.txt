https://www.zhihu.com/column/c_1466519585947688960
https://github.com/yezihack/algo

https://pan.baidu.com/s/11CwUsygbzjhBwBK40no7pA 提取码:x4as

算法:
6章串--BF和KMP
6章-图 Dijkstra算法(迪杰斯特拉-最短路径)





一、
1.1数据结构的研究内容

- 早期主要计算机用于数值，现在主要用于非数值。

- 计算机主要用于数值计算时， 一般要经过如下几个步骤:
  首先从具体问题抽象出数学模型， 
  然后设计一个解此数学模型的算法，
  最后编写程序，
  进行测试、
  调试，
  直到解决问题。

- 例子： 学生学籍管理系统(转成“线性”处理)、人机对弈问题(转成“树”处理)、最短路径问题(转成“图”处理)

- 非数值计算问题的数学模型不再是数学方程，而是诸如
  线性表、 树和图的数据结构。


- 数据机构基本概念和术语 数据 > 数据对象 > 数据元素(也称元素、记录) > 数据项(最小单位)
（数据对象： 多个数据元素组成;数据的一个子集数据对象）

- 程序 = 数据结构（Data Structure） + 算法

- 抽象数据类型: ：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合


- 算法：五个重要特性：有穷性、确定性、可行性、输入、输出；基本标准： 正确性、可读性、健壮性、高效性


- 分析算法： 时间复杂度和空间复杂度

- 逻辑结构：
    线性结构
        线性表（顺序表——线性表的顺序存储结构、 链表-线性表的链式存储）
        栈（特殊线性表）
        队列（特殊线性表）
        字符串（顺序）、数组、广义表
    非线性结构
        树形结构
        图形结构


- 存储结构的种类四种基本的存储结构:
    顺序存储结构
    链式存储结构
    索引存储结构
    散列存储结构


&a代表引用类型









二章、线性表







三章、栈、队列








四章

单链表：
1. 取值：链表不是随机存储的，而是顺序存储
2. 插入（新节点先指向后面，在用前节点指向新节点）
3. 删除（前指针替换成下下指针，当前值删除）
4. 取值O（n）；知道位置的插入和删除是常量O（1），未知O（n）
5. 
头插法：元素插入到链表头部，也叫前插法；先把新节点指向上个存储结点，当前新节点被首结点指向）
尾插法：元素插入到链表尾部，也叫后插法；新结点）

双链表：
双向：以单区别是多了头指针prior；空表就是头尾都是^（结构对称性）
1. 插入，先头prior和next，在尾prior和next






五章

5.1-2 栈和队列，都是线性表的子集（栈：后进先出；队列：先进先出）

5.3 队列Q（定义、逻辑结构存储结构、运算规则、实现方式）

5.4 栈4个案例：栈（进制转换、括号匹配的检验、表达式求值—需要两个栈【一个算符、一个运算数和结果】、队列（舞伴问题-两个队列，一男一女） 

5.5栈定义和抽象类型定义（S、InitStack、DestroyStack、StackEmpty、StackLength、GetTop、ClearStack、Push、Pop）

5.6顺序栈的表示与实现（存top和base指针、stacksize；空栈：top和base相等；满栈top-base=stacksize；上溢和下溢）

5.7顺序栈的初始化实现

5.8顺序栈判空、长度、清空、入栈、出栈

5.11栈与递归（分治法求解，栈与递归）

5.12（队列表现，循环队列的定义/队列定义（一个变量，一个头指针和一个尾指针）

5.13循环队列入栈和出栈假溢出处理：长度、入队：模处理-（n+1）%6=0、出队也是模处理、队空和队满指针都相等，区分设置标志或者设置变量记录与少用一个元素

5.14循环队列实现：初始化、长度、入队、出队、取队头）-%MAXQSIZE






六章（串-字符串（BF算法，KMP算法）；数组；广义表--有子集的数组）

6.1（串string：串名、串值、串长、空串—の、子串、真子串—不包含自己、主串、字符位置、子串位置、空格串、串相等、所有的空串都是相等的）
6.2串的定义
6.3串的顺序存储和链式存储定义（串链式存储多个字符存在一个块里提高存储密度—块链）,串常用顺序存储方式
6.5串的模式匹配算法-BF算法（思路穷举法-匹配失败i=i-j+2；j=1）；时间复杂度O(n*m)--bf.js

6.6数组介绍（1维到多度，特点结构固定-维度
6.7数组的定义（bi表示第几维的长度
6.8数组顺序存储：一维，二维，多维

6.9 对称矩阵，三角矩阵
6.10 对角矩阵：n阶对角矩阵的存储空间为：n*对角数
6.11 稀疏矩阵，t/(m*n)<=0.05,三元组（i，j，aij）；链式存储，十字链表


6.12 广义表（可以有子集的线形表；原子不是子表的；表尾是a2-an；深度是括号有几层，空表1层，原子0层；属性：共享—引用子表，递归—自己引用自己，多层次—子表套子表）；
基本运算：表头，表尾；
存储方式链表，不能是顺序表








七章
7.1树的定义：根和子结点；其他表示方式—嵌套集合、广义表、凹入表示
7.2基本术语（14个）
7.3二叉树定义，与树区别是区分左右；5种基本形态；3个结点有5个形态，但树就只有2种形态
7.4案例引入介绍：数据压缩问题和利用二叉树求解表达式的


7.11二叉树的常见三种遍历方法： (DLR————先根（序）遍历，根左右、LDR————中根遍历，左根右、LRD————后根遍历，左右根)
7.12中和先序二叉树/中和后序二叉树确定一颗二叉树

8.1 遍历二叉树的实现——递归算法
8.3 中序二叉树非递归算法
8.4 二叉树层次遍历
8.5 建立先序二叉树（#确认树位置）
8.6 二叉树的应用：复制（根结点复制给新结点后遍历左右结算点）、深度（左右子树的深度取最大值+1）;结点总个数（左子树+右子树+1）;叶子结点的个数
8.7 搜索二叉树：
8.8 树和森林；树的存储结构：双亲表示法-数据域和双亲域（data，parent，r，n，特点找双亲容易，孩子难
8.9 树-孩子链表（孩子结点：下标和下一个兄弟结点；双亲结点：值和第一个孩子的指针；树：头指针，结点总数和根结点下标）特点找孩子容易，找双亲难，解决孩子加个双亲结点下标
8.10 孩子兄弟表示法（父结点指向头结点，头结点一边指向下一个兄弟结点，一边指向子结点）
8.11 树转二叉树（1.兄弟加线;2.父结点保存首结点；3.顺时钟旋45度——兄弟相连流长子）二叉树转树（1.父结点将孙及之后的右结点相连；2.删原父结点右结点；3.调整成树结构）


9.1 哈夫曼树又称最优二叉树（ 例子：百分制转换五分制；左树结果右树下一分制，小于60转化先判断80的，有点二分法）
9.2 概念（
路径、
结点的路径长度、
树的路径长度：各个结点之和、
权：给结点有意义的值、
结点的带权路径长度：根结点到结点的长度乘以意义的值、树的带权路径长度：树所有带权叶子路径长度之和）
哈夫曼树（带权路径长度最短、最优二叉树、权值越大离根越近）
9.3 构建哈夫曼树思路（1、构造森林全是根;2、选用两小造新树;3、删除两小添新人； 4、重复2、3剩单根。—n-1次组合）（结点的度只有0和2没有1）2n-1个结点
9.4 实现（顺序存储、定义4个数据：权值、双亲、左孩子、右孩子
代码实现（输入n是叶子结点，共2n-1个结点
根据权值从最小两个开始合并
9.5 应用—哈夫曼编码（字符重复用编码短的表示，反之亦然）左边是0右边是1，编码就是从结点到根的0/1相加
9.6 应用—哈夫曼编码表转编码，（用while判断终止条件是父母结点为0，从叶子开始往父结点找，代码讲解）
9.7 应用—例子
编码：
①输入各字符及其杈值
② 构造哈夫曼树-
-HT[i
③ 进行哈夫曼编码-
④ 查HC的，得到各字符的哈夫曼编码
解码：
①构诰哈夫曼树
② 依次读入二进制码
 读人0）则走向左孩子；渎入1，则走向右孩子
② 一旦到达某叶子时，即可译出字符
⑤ 然后再从根出发继续译码，指导结束


9.8 图的定义和术语：
9.10 案例引入：六度空间理论
9.11 图的类型定义（建立、深度遍历、广度遍历）



10.1-2 图的存储结构
一、链式存储数组表示法（领接矩阵）；（结构：一维数组存顶点，二维数组存关系矩阵）
  无向
    分析1. 无向图的邻接矩阵是对称的；
    分析2. 顶点i的度=第 1行(列中1的个数;
    分析3. 特别：完全因的邻接矩阵中，对角元素为0，其余1
  有向
    分析1：有向图的邻接矩阵可能是不对称的。
    分析2：顶点的出度=第i行元素之和、顶点的入度=第冽元素之和
二、多重链表（领接表、领接多重表、十字链表）
  顶点的出度=第i行元素之和
  顶点的入度=第i列元素之和
  顶点的度=第i行元素之和＋第i列元素之和
  （图的矩阵用0和1表示，网（带权值路径的）的矩阵用值和∞（无边-弧）表示）


10.3 无向网的领接矩阵代码（结构：一维数组，二维数组，点数，边数）


10.4 领接矩阵优缺点
优点
直观、简单、好理解
方便检查任意一对顶点间是否存在边
方便找任一顶点的所有“邻接点〞（有边直接相连的顶点）
方便计算任一顶点的“度”
（从该点发出的边
数为“出度〞，指向该点的边数为 “入度”）
•无向图：对应行（或列）非0元素的个数
•有向图：对应行非0元素的个数是“出度〞；
对应列非0元素的个数是“入度”
缺点
不便于增加和删除顶点
，浪费空间一—存稀疏图 人点很多而边很少） 有大量无效元素
•对稠密图（特别是完全图）还是很合算的
•浪费时间-—统计稀疏图中一共有多少条边

10.5-6 图的存储结构2–领接表（链式）
无向表
特点
邻接表不唯一
••若无向图中有 n个顶点、e条边，则其邻接表需 n个头结和2e个表結点。适宜存儲稀疏圏图。
•无向图中顶点Vi的度为第i个单链表中的结点数

有向表
顶点Vi的出度为第i个单链表中的结点个数。
顶点Vi的入度为整个单链表中邻接点域值是 i-1的结点个数
（找出度易，入度难）
所以有逆领接表
- 顶点Vi的入度为第 i个单链表中的结点个数。
- 顶点Vi的出度为整个单链表中邻接点域值是 i-1 的结点个数。
（找入度易，出度难）

10.7无向图领接表算法代码（数组，单链表（顶点和下一顶点地址），结点，边）

10.8
领接表特点
方便找任一顶点的所有“邻接点”
节约稀疏图的空间
•需要N个头指针＋2E个结点 （每个结点至少2个域）
方便计算任一顶点的“度〞？
•对无向图：是的
•对有向图：只能计算“出度〞；需要构造“近邻接表”（存指向自己的边）来方便计算“度
不方便检查任意一对顶点间是否存在边

领接矩阵和表
1. 联系
邻接表中每个链表对应于邻接短阵中的一行，链表中结点个数等于一行中非零元素的个数。
2. 区别：
对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号—致），但邻接表不唯—(链接次序与顶点编号无关）。
② 邻接矩阵的空间复杂度为O(n2),而邻接表的空问复杂度为O(n+e)。
3. 用途：邻接矩阵多用于稠密图;而邻接表多用手稀疏图


10.9 十字链表（存领接表和逆领接表解决遍历入度的问题（有向领接表-多维数组多加“入度结点”）


10.10 无线领接表（问题出现边两次遍，用领接多重表）



10.11 图的遍历：
1.深度优先搜索 (Depth First Search-DFS）—点亮灯的例子，一条道走到黑
2. 广度优先搜索 ( Breadth Frist Search-BFS）



10.12-13深度用栈
10.14 广度一层一层访问，实现领接表，队列


















11.1 图的应用

生成树回顾-
概念：所有顶点均由边连接在一起，但不存在回路的图
共同特点：
.生成树的顶点个数与图的顶点个数相同；
.生成树是图的极小连通子图，去掉一条边则非连通；
• 一个有八个顶点的连通图的生成树有 八-1 条边；
•在生成树中再加一条边必然形成回路。
•生成树中任意两个顶点间的路径是唯一的；

无向图的生成树（遍历进过得到）：
深度优先生成树
广度优先生成树


11.2 图的应用
最小生成树：无向网，生成树中权值相加最小 （应用：城市网络，道路-最小需要n-1条路，路的权值就是造价，最多有n(n-1)/2条路)



11.3 MST 最小权值（最小生成树）













12查找

线性表的查找

 + 顺序查找
   - 时间复杂度O(n)
   - 查找成功的平均查找长度 ASL=n+1/2
   - 空间复杂度O(1)

 + 二分查找（折半查找）
   - 时间复杂度O(log₂ⁿ)
   - 成功时的平均查找长度O(log₂ⁿ⁺¹-1)
 + 分块查找
   成功时的平均查找长度ASLb+ALSw = log₂b/ⁿ⁺¹ + s/2



        顺序查找          二分查找    分块查找
ASL     最大              最小       中间
表结构   有/无序表         有序表     分块有序
存储结构 顺序表、线性链表   顺序表     顺序表、线性链表


顺序优先用二分，后分块查找，后顺序查找




13.1-2 
平衡二叉树：左右结点和左右树深度绝对值不能大于1；
四种处理平衡二叉树的类型：LL、LR、RL、RR








# C

['gcc' is not recognized as an internal or external command, operable program](https://blog.51cto.com/u_15292864/2973678)
[11111](https://www.it610.com/article/1424574512837545984.htm)