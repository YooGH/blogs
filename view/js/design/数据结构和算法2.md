1. <a href="#h8"> 八章 </a>
2. <a href="#h9"> 九章 </a>
3. <a href="#h10"> 十章 </a>
4. <a href="#h11"> 十一章 </a>
5. <a href="#h12"> 十二章 </a>
6. <a href="#h13"> 十三章 </a>
7. <a href="#h14"> 十四章 </a>
********************





om/column/c_1466519585947688960
https://github.com/yezihack/algo

https://pan.baidu.com/s/11CwUsygbzjhBwBK40no7pA 提取码:x4as



<br/><br/>
<h1 id='h8'>八章</h1>

```
8.1 遍历二叉树的实现——递归算法
8.3 中序二叉树非递归算法
8.4 二叉树层次遍历
8.5 建立先序二叉树（#确认树位置）
8.6 二叉树的应用：复制（根结点复制给新结点后遍历左右结算点）、深度（左右子树的深度取最大值+1）;结点总个数（左子树+右子树+1）;叶子结点的个数
8.7 搜索二叉树：
8.8 树和森林；树的存储结构：双亲表示法-数据域和双亲域（data，parent，r，n，特点找双亲容易，孩子难
8.9 树-孩子链表（孩子结点：下标和下一个兄弟结点；双亲结点：值和第一个孩子的指针；树：头指针，结点总数和根结点下标）特点找孩子容易，找双亲难，解决孩子加个双亲结点下标
8.10 孩子兄弟表示法（父结点指向头结点，头结点一边指向下一个兄弟结点，一边指向子结点）
8.11 树转二叉树（1.兄弟加线;2.父结点保存首结点；3.顺时钟旋45度——兄弟相连流长子）二叉树转树（1.父结点将孙及之后的右结点相连；2.删原父结点右结点；3.调整成树结构）
```

<br/><br/>
<h1 id='h9'>九章</h1>
9.1 哈夫曼树又称最优二叉树（ 例子：百分制转换五分制；左树结果右树下一分制，小于60转化先判断80的，有点二分法）<br/>
9.2 概念（<br/>
- 路径、
- 结点的路径长度、
- 树的路径长度：各个结点之和、
- 权：给结点有意义的值、
- 结点的带权路径长度：根结点到结点的长度乘以意义的值、树的带权路径长度：树所有带权叶子路径长度之和）
- 哈夫曼树（带权路径长度最短、最优二叉树、权值越大离根越近）<br/>
9.3 构建哈夫曼树思路（1、构造森林全是根;2、选用两小造新树;3、删除两小添新人； 4、重复2、3剩单根。—n-1次组合）（结点的度只有0和2没有1）2n-1个结点<br/>
9.4 实现（顺序存储、定义4个数据：权值、双亲、左孩子、右孩子<br/>
代码实现（输入n是叶子结点，共2n-1个结点<br/>
根据权值从最小两个开始合并<br/>
9.5 应用—哈夫曼编码（字符重复用编码短的表示，反之亦然）左边是0右边是1，编码就是从结点到根的0/1相加<br/>
9.6 应用—哈夫曼编码表转编码，（用while判断终止条件是父母结点为0，从叶子开始往父结点找，代码讲解）<br/>
9.7 应用—例子<br/>

```
编码：
①输入各字符及其杈值
② 构造哈夫曼树-
-HT[i
③ 进行哈夫曼编码-
④ 查HC的，得到各字符的哈夫曼编码
解码：
①构诰哈夫曼树
② 依次读入二进制码
 读人0）则走向左孩子；渎入1，则走向右孩子
② 一旦到达某叶子时，即可译出字符
⑤ 然后再从根出发继续译码，指导结束
```

<br/><br/>
9.8 图的定义和术语：<br/>
9.10 案例引入：六度空间理论<br/>
9.11 图的类型定义（建立、深度遍历、广度遍历）<br/>

<br/><br/>
<h1 id='h10'>十章</h1>
10.1-2 图的存储结构<br/>
一、链式存储数组表示法（领接矩阵）；（结构：一维数组存顶点，二维数组存关系矩阵）<br/>

```
  无向
    分析1. 无向图的邻接矩阵是对称的；
    分析2. 顶点i的度=第 1行(列中1的个数;
    分析3. 特别：完全因的邻接矩阵中，对角元素为0，其余1
  有向
    分析1：有向图的邻接矩阵可能是不对称的。
    分析2：顶点的出度=第i行元素之和、顶点的入度=第冽元素之和
```

二、多重链表（领接表、领接多重表、十字链表）<br/>

```
  顶点的出度=第i行元素之和
  顶点的入度=第i列元素之和
  顶点的度=第i行元素之和＋第i列元素之和
  （图的矩阵用0和1表示，网（带权值路径的）的矩阵用值和∞（无边-弧）表示）
```


10.3 无向网的领接矩阵代码（结构：一维数组，二维数组，点数，边数）<br/>

<br/><br/>
10.4 领接矩阵优缺点<br/>
优点<br/>
直观、简单、好理解<br/>
方便检查任意一对顶点间是否存在边<br/>
方便找任一顶点的所有“邻接点〞（有边直接相连的顶点）<br/>
方便计算任一顶点的“度”<br/>

```
（从该点发出的边
数为“出度〞，指向该点的边数为 “入度”）
•无向图：对应行（或列）非0元素的个数
•有向图：对应行非0元素的个数是“出度〞；
对应列非0元素的个数是“入度”
缺点
不便于增加和删除顶点
，浪费空间一—存稀疏图 人点很多而边很少） 有大量无效元素
•对稠密图（特别是完全图）还是很合算的
•浪费时间-—统计稀疏图中一共有多少条边
```

10.5-6 图的存储结构2–领接表（链式）<br/>

```
无向表
特点
邻接表不唯一
••若无向图中有 n个顶点、e条边，则其邻接表需 n个头结和2e个表結点。适宜存儲稀疏圏图。
•无向图中顶点Vi的度为第i个单链表中的结点数

有向表
顶点Vi的出度为第i个单链表中的结点个数。
顶点Vi的入度为整个单链表中邻接点域值是 i-1的结点个数
（找出度易，入度难）
所以有逆领接表
- 顶点Vi的入度为第 i个单链表中的结点个数。
- 顶点Vi的出度为整个单链表中邻接点域值是 i-1 的结点个数。
（找入度易，出度难）
```

<br/><br/>
10.7无向图领接表算法代码（数组，单链表（顶点和下一顶点地址），结点，边）

<br/><br/>
10.8

```
领接表特点
方便找任一顶点的所有“邻接点”
节约稀疏图的空间
•需要N个头指针＋2E个结点 （每个结点至少2个域）
方便计算任一顶点的“度〞？
•对无向图：是的
•对有向图：只能计算“出度〞；需要构造“近邻接表”（存指向自己的边）来方便计算“度
不方便检查任意一对顶点间是否存在边
```

```
领接矩阵和表
1. 联系
邻接表中每个链表对应于邻接短阵中的一行，链表中结点个数等于一行中非零元素的个数。
2. 区别：
对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号—致），但邻接表不唯—(链接次序与顶点编号无关）。
② 邻接矩阵的空间复杂度为O(n2),而邻接表的空问复杂度为O(n+e)。
3. 用途：邻接矩阵多用于稠密图;而邻接表多用手稀疏图
```

<br/><br/>
10.9 十字链表（存领接表和逆领接表解决遍历入度的问题（有向领接表-多维数组多加“入度结点”）<br/>

<br/><br/>
10.10 无线领接表（问题出现边两次遍，用领接多重表）<br/>


<br/><br/>
10.11 图的遍历：<br/>
1.深度优先搜索 (Depth First Search-DFS）—点亮灯的例子，一条道走到黑<br/>
2. 广度优先搜索 ( Breadth Frist Search-BFS）<br/>


<br/><br/>
10.12-13深度用栈<br/>
10.14 广度一层一层访问，实现领接表，队列<br/>







<br/><br/>
<h1 id='h11'>十一章</h1><br/>
11.1 图的应用<br/>

```
生成树回顾-
概念：所有顶点均由边连接在一起，但不存在回路的图
共同特点：
.生成树的顶点个数与图的顶点个数相同；
.生成树是图的极小连通子图，去掉一条边则非连通；
• 一个有八个顶点的连通图的生成树有 八-1 条边；
•在生成树中再加一条边必然形成回路。
•生成树中任意两个顶点间的路径是唯一的；

无向图的生成树（遍历进过得到）：
深度优先生成树
广度优先生成树
```

<br/><br/>
11.2 图的应用<br/>
最小生成树：无向网，生成树中权值相加最小 （应用：城市网络，道路-最小需要n-1条路，路的权值就是造价，最多有n(n-1)/2条路)


<br/><br/>
11.3 MST 最小权值（最小生成树）<br/>







<br/><br/>
<h1 id='h12'>十二章</h1><br/>

查找: 线性表的查找<br/>


||顺序查找|二分查找|分块查找|
|:---|:---|:---|:---|
|ASL|最大|最小|中间|
|表结构|有/无序表|有序表|分块有序|
|存储结构|顺序表、线性链表|顺序表|顺序表、线性链表|
|复杂度|时间复杂度O(n)<br/>查找成功的平均查找长度 ASL=n+1/2<br/>空间复杂度O(1)|时间复杂度O(log₂ⁿ)<br/>成功时的平均查找长度O(log₂ⁿ⁺¹-1)|成功时的平均查找长度ASLb+ALSw = log₂b/ⁿ⁺¹ + s/2|

<br/>顺序优先用二分，后分块查找，后顺序查找









<br/><br/>
<h2 id='h13'>十三章</h2><br/>

13.1-2 <br/>
平衡二叉树：左右结点和左右树深度绝对值不能大于1；<br/>
四种处理平衡二叉树的类型：LL、LR、RL、RR<br/>










<br/><br/>
<h2 id='h14'>十四章</h2><br/>

排序方法的分类

|依据|类型|
|:--|:--|
|按数据存储介质|内部排序和外部排序|
|按比较器个数|串行排序和并行排序|
|按主要操作|比较排序和基数排序|
|按辅助空间|原地排序和非原地排序|
|按稳定性|稳定排序和非稳定排序|
|按自然性|自然排序和非自然排序|



|类别|排序方法|最好情况|最坏情况|平均情况|辅助存储|稳定性|
|:--|:--|:--|:--|:--|:--|:--|
|插入排序|直接插入排序|O(n)|O(n²)|O(n²)|O(1)|稳定|
|插入排序|希尔排序|O(n)|O(n²)|~O(n^(1.3))|O(1)|不稳定|
|交换排序|冒泡排序|O(n)|O(n²)|O(n²)|O(1)|稳定|






# C

['gcc' is not recognized as an internal or external command, operable program](https://blog.51cto.com/u_15292864/2973678)
[11111](https://www.it610.com/article/1424574512837545984.htm)