- 1. JavaScript 简介
- 2. ECMAScript 和 TypeScript 概述
- 3. 数组（45|62）
- 4. 栈（67|84）
- 5. 队列和双端队列（82|99）
- 6. 链表(94|111)
- 7. 集合(118|135)
151
字典和散列表(134|151)、递归、树
二叉堆和堆排序、图、排序和搜索算法、算法设计与技巧、算法复杂度



2.JavaScript数据结构与算法第3版
[ES浏览器兼容](http://kangax.github.io/compat-table/es5/)
[babel](https://babeljs.io/repl)










4章：
①、栈是一种遵从后进先出（LIFO）原则的有序集合。栈顶-新元素，栈底-旧元素（应用：浏览器历史记录,子弹壳装弹，叠书）- 96（4.5）
仅仅用于线性表

②、类的私有属性用1. 下划线标识(实际还是能访问) -> 2. yong Symbol(实际getOwnProperty-Symbols可以访问) -> 3.WeakMap真正实现私有属性，但可读性差并且私有属性不能被继承 -> 4. 提案在属性前加#(如ts,c属性前加private)

③、new Stack()-(73|90)

1. 添加：push
2. 移除：pop
3. 查看队列头元素: peek() (当前第一个元素)
4. 队列是否为空: isEmpty() (是否是空)
5. 长度: size() （length）
6. 清空: clear() （一直调dequeue直到undefined或初始化）
7. 转字符串: toString()

class Stack {
  constructor() {
    this._count = 0;
    this._items = [];
  }
  push(element) {
    this._items[this._count] = element;
    this._count++
  }
  pop() {
    if(this.isEmpty()) { return undefined; };
    this._count--
    const result = this._items[this._count];
    delete this._items[this._count]
    return result
  }
  peek() {  // 栈顶元素、
    if(this.isEmpty()) { return undefined; };
    console.log(this._items)
    console.log(this._count)
    return this._items[this._count - 1]
  }
  isEmpty() {
    return this._count === 0
  }
  size() {
    return this._count
  }
  clear() {
    this._count = 0;
    this._items = [];
  }
  toString() {
    if(this.isEmpty()) { return '' }
    let objString = '';
    for(let i=0; i<this._count; i++) {
      objString += `${this._items[i]}`
    }
    return objString
  }
}

④、属性私有：属性前下划线 -> Symbol -> WeakMap -> [属性前#提案](https://github.com/tc39/proposalclass-fields)


const items = new WeakMap();
class Stack {
  constructor () {
    items.set(this, []);
  }
  push(element){
    const s = items.get(this);
    s.push(element);
  }
  pop(){
    const s = items.get(this);
    const r = s.pop();
    return r;
  }
} 










5章：
队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项(应用：排队做核酸)
双端口队列（应用：回文），循环队列（应用：击鼓传花游戏）


1. 添加：enqueue（push）
2. 移除：dequeue（shift）
3. 查看队列头元素: peek() (当前第一个元素)
4. 队列是否为空: isEmpty() (是否是空)
5. 长度: size() （length）
6. 清空: clear() （一直调dequeue直到undefined或初始化）


class Queue {
  constructor() {
    this.count = 0;
    this.lowestCount = 0;
    this.items = {};
  }
  enqueue(element) {
    this.items[this.count] = element;
    this.count++
  }
  dequeue() {
    if(this.isEmpty()) { return undefined; };
    const result = this.items{this.lowestCount};
    delete this.items{this.lowestCount}
    this.lowestCount++;
    return result
  }
  peek() {
    if(this.isEmpty()) { return undefined; };
    return this.items{this.lowestCount}
  }
  isEmpty() {
    return this.count - this.lowestCount === 0;
  }
  size() {
    return this.count - this.lowestCount
  }
  clear() {
    this.count = 0;
    this.lowestCount = 0;
    this.items = {};
  }
  toString() {
    if(this.isEmpty()) { return ''; };
    let objString = `${this.items{this.lowestCount}}`;
    for (let i = this.lowestCount + 1; i < this.count; i++) {
      objString = `${objString},${this.items[i]}`;
    }
    return objString;
  }
}





5.2.1双端队列数组结构（与双端队列，就是多少后进和后出操作）
class Deque{
  constructor() {
    this.count = 0;
    this.lowestCount = 0;
    this.items = {};
  }
  addFront(element) {
    if (this.isEmpty()) { // 队列空
      this.addBack(element);
    } else if (this.lowestCount > 0) { // 队列被删除
      this.lowestCount--;
      this.items[this.lowestCount] = element;
    } else {  // 先把之前的移动后一位，在塞进第一位置
      for (let i = this.count; i > 0; i--) { // {3}
        this.items[i] = this.items[i - 1];
      }
      this.count++;
      this.lowestCount = 0;
      this.items[0] = element; // {4}
    }
  } 
}

5.3.1循环队列
5.3.2回文检测器: 正反读有一样 -> madam  (比较就是前出和后出比较是否一致)










6章
export function defaultEquals(a, b) {
  return a === b;
}
class Node {
  constructor(element) {
    this.element = element;
    this.next = undefined;
  }
} 
export default class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 数组长度
    this.head = undefined; // 数组头结点(element和next)
    this.equalsFn = equalsFn; // 两元素是否相同
  }
  push(element) {
    const node = new Node(element); // 
    let current; // {2}
    if (this.head == null) { // 空数组
      this.head = node;
    } else {
      current = this.head; //
      while (current.next != null) { //  获得最后一项
        current = current.next;
      }
      // 将其 next 赋为新元素，建立链接
      current.next = node; // {6}
    }
    this.count++; // {7}
  }
  removeAt(index) {
   // 检查越界值
    if (index >= 0 && index < this.count) { // 
      let current = this.head; // 头结点
      // 移除第一项
      if (index === 0) { // 移除头指针只要把第二个结点放头部
        this.head = current.next;
      } else {
        let previous; // {4}
        for (let i = 0; i < index; i++) { // {5}
        previous = current; // {6}
        current = current.next; // {7}
      }
      // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它
      previous.next = current.next; // {8}
    }
    this.count--; // {9}
    return current.element;
    }
    return undefined; // {10}
  }
  getElementAt(index) {
    if (index >= 0 && index <= this.count) { // {1}
      let node = this.head; // {2}
      for (let i = 0; i < index && node != null; i++) { // {3}
        node = node.next;
      }
      return node; // {4}
    }
    return undefined; // {5}
  }
  removeAt(index) {  // 重构
   // 检查越界值
    if (index >= 0 && index < this.count) { // 
      let current = this.head; // 头结点
      // 移除第一项
      if (index === 0) { // 移除头指针只要把第二个结点放头部
        this.head = current.next;
      } else {
        let previous;
        const previous = this.getElementAt(index - 1);
        current = previous.next;
        previous.next = current.next; 
      }
    }
    this.count--; // {9}
    return current.element;
    }
    return undefined; // {10}
  }
  indexOf(element) {
    let current = this.head;
    for (let i=0; i < this.count && current != null; i++) {
      if(this.equalsFn(element, current.element)){ // 判断传入元素与当前元素是否一致
        return i
      }
      current = current.next // 循环指向下一个
    }
    return -1
  }
  remove(element) {
    const index = this.indexOf(element);
    return this.removeAt(index);
  }
  isEmpty() {
    return this.size() === 0;
  }
  size() {
    return this.count;
  }
  getHead() {
    return this.head;
  }
  toString() {
    if(this.head == null) {
      return '';
    }
    let objString = `${this.head.element}`;
    let current = this.head.next;
    for(let i=1; i<this.size() && current !=null; i++) {
      objString += current.element;
      current = current.next; // 指针 
    }
    return objString;
  }
}
1. 添加元素 push
2. index移除元素 removeAt
3. 循环迭代链表直到目标位置 getElementAt(下标找元素)
4. 任意位置插入元素
5. 返回一个元素的位置(indexOf) 9.27
6. 从链表中移除元素(remove) 9.27
7. isEmpty、size 和 getHead 方法 9.27
8. toString()



6.2双向链表(多了个前节点)
> 比单链表多了前指针，和对应重写的插入和移除方法

class DoublyNode extends Node {
  constructor(element, next, prev) {
    super(element, next);
    this.prev = prev
  }
}

class DoublyLinkedList extends LinkedList {
  constructor(equalsFn = defaultEquals) {
    super(equalsFn);
    this.tail = undefined // 最后元素引用
  }
  insert(element, index) {
    if(index >= 0 && index <= this.count) {
      const node new DoublyNode(element);
      let current = this.head;
      // 头插入
      if(index === 0) {
        if(this.head == null) {
          this.head = node;
          this.tail = node;
        } else {
          node.next = this.head;
          current.prev = node;
          this.head = node
        }
      // 尾插入
      } else if (index === this.count) {
        current = this.tail;
        current.next = node
        node.prev = current;
        this.tail = node
      } else {
        const previous = this.getElementAt(index - 1); // 获取插入元素前一个
        current = previous.next;
        node.next = current;
        previous.next = noex;
        current.prev = node;
        node.prev = previous;
      }
      this.count++
      return true
    }
    return false;
  }
  removeAt(index) {
    if(index >= 0 && index <= this.count) {
      let current = this.head;
      if(index === 0) {
        this.head = current.next;
        if(this.count === 1) {
          this.tail = undefined
        } else {
          this.haed.prev = undefined;
        }
      } else if(index === this.count - 1) {
        current = this.tail;
        this.tail = current.prev;
        this.tail.next = undefined;
      } else {
        current = this.getElementAt(index);
        const previous = current.prev;
        previous.next = current.next;

        previous.next = current.next;
        current.next.prev = previous
      }
      this.count--;
      return current.element;
    }
    return undefined; // 与insert返回false有区别
  }
}



6.3 循环链表就是将单链或双链最后元素下一个元素的指针（tail.next）指向第一个元素



6.4 有序链表










7章
集合: 不允许值重复的顺序数据结构

一、创建集合类
- add(element)：向集合添加一个新元素。 
- delete(element)：从集合移除一个元素。 
- has(element)：如果元素在集合中，返回 true，否则返回 false。 
- clear()：移除集合中的所有元素。 
- size()：返回集合所包含元素的数量。它与数组的 length 属性类似。 
- values()：返回一个包含集合中所有值（元素）的数组。

class Set {
  constructor() {
    this.items = {};
  }
  has(element) {
    //方法一,会得到非当前的属性 return element in this.tiems
    return Object.prototype.hasOwnProperty.call(this.items, element);
  }
  add(element) {
    if(!this.has(element)) {
      this.items[element] = element;
      return true;
    }
    return false;
  }
  delete(element) {
    if(!this.has(element)) {
      delete this.items[element];
      return true;
    }
    return false;
  }
  clear() {
    this.items = {};
  }
  size() {
    return Object.keys(this.items).length;
  }
  sizeLegacy() {
   let count = 0;
   for(let key in this.items) {
     if(this.items.hasOwnProperty(key)) {
       count++;
     }
   }
   return count;
  }
  values() {
    return Object.values(this.items)
  }
  valuesLegacy() {
    let values = [];
    for(let key in this.items) {
      if(this.items.hasOwnProperty(key)) {
       values.push(key)
     }
    }
    return values
  }
}


二、 扩展运算
- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集
合的元素的新集合。
- 子集：验证一个给定集合是否是另一集合的子集。
class Set {
  ...
  union(otherSet) { // 并集，创建新的Set见新旧集合推进去(concat)
    const unionSet = new Set();
    this.values.forEach(value => unionSet.add(valuse));
    otherSet.values.forEach(value => unionSet.add(valuse));
    return unionSet;
  }
  intersection(otherSet) { // 交集，可以优化成判断哪个长度小的遍历哪个(127|144)
    const intersectionSet = new Set();
    const values = this.values();
    otherSet.values.forEach(value => {
      if(this.has(value)) {
        intersectionSet.add(value)
      }
    })
    return intersectionSet
  }
  difference(otherSet) { // 差集，不和本集合一样的值
    const differenceSet = new Set();
    this.values().forEach(value => {
      if (!otherSet.has(value)) {
        differenceSet.add(value);
      }
    });
    return differenceSet;
  }
  isSubsetOf(otherSet) {  // 子集
    if (this.size() > otherSet.size()) { // 大于本集合就不是子集合
      return false;
    }
    let isSubset = true;
    this.values().every(value => {
      if (!otherSet.has(value)) {
        isSubset = false;
        return false;
      }
      return true;
    });
    return isSubset;
  } 
}


三、ES2015-Set类
原来的 Set 不同: values 方法返回 Iterator、size方法ES6是size属性、没有扩展运算(并集等)

用新特性扩展运算符(将集合转化为数组；执行需要的运算；将结果转化回集合)改写扩展运算,主要作用就是将集合转成数组方便运算，例如：
union(setA, setB) { new Set([...setA, ...setB]) } // 并集
difference(setA, setB)new Set([...setA].filter(x => !setB.has(x))) // 差集


四、[多重集或袋](https://github.com/loiane/javascript-datastructures-algorithms):集合可以添加重复的值
























宿主发起的任务为宏观任务(setTimeout)，js引擎发起的任务为微观任务(ES5之后的Promise),引擎等待宿主环境分配任务发起，node也叫事件循环




路由: config/permission.js => 做了路由守卫router.beforeEach








CICD(1week)
ESLint   怎么更改、vscode插件(1week)
用vim打包项目（看看原来的打包项目时间）(1week)
trao--E: ai_trao(手动转)/ai_mdt_xcx-taro(自转)（file:///D:/a/blogs/view/other/taro.md）
diff: https://mp.weixin.qq.com/s/esHgaLjr6plHxaidFw9iVw（到：此方法就是diff算法的核心部分）

1. vue源码
2. 设计模型
3. ES6
4. done空间算法时间算法
5. docker18开始,共30

9月(看看skill、过过一)
一、对象、数组、字符串、敲敲排序代码2
skill(docker/算法)、js
设计模式(结构1-2)
搭建小vue



Object(object; 14: vue)


队列：先进先出（排队）


