const cssList = [
  { id: 1, sort: 1, type: 'css', question: '文字超出', answer: 'width: 宽度;              // flex布局可以用flex: 0 0 宽度;\noverflow: hidden;\ntext-overflow: ellipsis; // ...省略号\nwhite-space: nowrap;     // 超出不换行(no+wrap)', details: 'width: 宽度;\noverflow: hidden;\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 2;            // 多行溢出，需要-webkit-box，因为不是规范内的，有兼容问题'},
  { id: 2, sort: 2, type: 'css', question: '选择器级别', answer: '选择器排序： id选择器 > 类选择器 > 属性选择器 > 标签选择器 > 通配符选择器', details: '!import > 内联样式 > 选择器  \n关系选择符``（后代，子， +, ~）``、伪类选择符、伪对象选择符'},
  { id: 3, sort: 3, type: 'css', question: '居中', answer: '1. flex => display: flex; justify-content: center; align-items: center;\n 2.position: absolute; top: 50%; left: 50%; margin: auto; transform:translate(-50%,-50%)\n 3.position: absolute; width: 100%; height: 100%; left: 0; top: 0; bottom: 0; right: 0; margin: auto;(子元素也会居中)'},
  { id: 4, sort: 4, type: 'css', question: '清浮动', answer: '1.空标签(元素)间隔\n2.:after/:before(伪元素)\n3.clear:both;(只在block元素起作用，并且影响上下文元素)\n4.overflow:hidden;(缺点：元素需要滚动不能用)\n5.父子都浮动（缺点: 父元素周围元素不换行）', details: '清浮动原因：\n父级没有高度时，父级的高度是由子元素撑开的，但子元素浮动后，父元素的高度无法被撑开，所以需要清浮动；(父元素为0)\n新加入的兄弟级标签，希望不受之前浮动元素的影响，则需要清浮动'},
  { id: 5, sort: 5, type: 'css', question: 'css中padding和margin区别', answer: 'margin是用来隔开元素与元素的间距;\npadding是用来隔开元素与内容的间隔'},
  { id: 6, sort: 6, type: 'css', question: 'CSS 雪碧图的好处', answer: '1.合并多少图片，减少页面请求次数\n2.提高加载速度\n3.方便风格更改，查找', details: '雪碧-Sprite-精灵,雪碧饮料为了好听取得，直译是精灵的意思'},
  { id: 7, sort: 7, type: 'css', question: 'position属性用于元素定位有几种方式，相对定位和绝对定位的区别？', answer: 'fixed（固定定位，可视区）\nabsolute（绝对定位，相对父或上层）\nrelative（相对定位，相对当前位置）'},
  { id: 8, sort: 8, type: 'css', question: '有几种像素单位？em和rem有什么区别', answer: ' + px\nrem（相对于根元素html）\nem (相对于上级元素，没有设置也是根元素)\nvh和vw 可视区宽高总,共100(vmin,vmax)', details: 'rem相对于父元素(设置font-size)，rem相对于根元素（html）'},
  { id: 9, sort: 9, type: 'css', question: '自适应高度', answer: 'flex：\n父: display: flex; | 左边: width: 宽度; | 右边： width: 宽度; height: 高度;\nposition：父: position:relative; | 左边: position:absulote; height: 100%; width: 宽度; | 右边： width: 宽度; margin-left: 左边宽度; height: 100px;(父级高度随右侧兼容，左侧高度设置100%继承父级)'},
  { id: 10, sort: 10, type: 'css', question: '两边固定，中间自适应；左边固定，右边自适应', answer: 'flex：\n父--display: flex;   左右两边--flex 0 0 100px;   中--flex: 1;padding: 0 100px;box-sizing: border-box;\nposition：\n父--position: relative;   左右两边--position: absolute;top: 0;left/right: 0; width: 100px;   中--width: 100%;padding: 0 100px;box-sizing: border-box;\nfloat：\n父--清浮动；左右两边--float: left/right; 中间: width: 100%;padding: 0 100px;box-sizing: border-box;    （中间元素标签放最后）'},
  { id: 11, sort: 11, type: 'css', question: '重绘和回流的概念', answer: '回流(重排): 当浏览器必须重新处理和绘制部分或全部页面时，回流就会发生；\n重绘: 不影响布局, 只是标签页面发生变化, 重新绘制；\n注意: 回流(重排)必引发重绘, 重绘不一定引发回流(重排)；', details: '重绘(repaint)：当元素样式改变而不影响元素在页面中的位置时，浏览器对元素进行更新这就是重绘；\n回流(reflow)：当元素样式改变而影响到其在页面中的位置和大小时，浏览器将对页面重新计算渲染树，这就是回流\n二者之间的关系：发生回流一定会触发重绘，但是触发重绘不一定会发生回流；\n举个简单的例子：\n因为元素的颜色的改变会导致元素的样式改变此时就触发了重绘，但是其并没有影响其在页面的位置和大小所以就没有触发回流；\n但是元素通过定位或者改变大小导致样式的改变此时即符合重绘的定义也符合回流的定义；因而即触发了重绘又触发了回流；\nDOM 样式发生了变化，但没有影响到页面布局时，会触发重绘，而不会触发回流。\n重绘由于 DOM 位置信息不需要更新，省去了布局过程，因而性能上优于回流'},
  { id: 12, sort: 12, type: 'css', question: 'iphoneX及以上苹果底部横条', answer: 'iphoneX及以上苹果底部横条 小程序（wx.getSystemInfo -> safeArea.bottom与可视区相减）'},
  { id: 13, sort: 13, type: 'css', question: '如果需要手动写动画，你认为最小时间间隔是多久？', answer: '多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为``1/60*1000ms ＝ 16.7ms ``'},
]